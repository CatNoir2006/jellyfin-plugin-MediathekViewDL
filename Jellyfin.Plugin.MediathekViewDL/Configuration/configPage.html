<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8">
    <title>MediathekView Plugin Konfiguration</title>
</head>

<body>
<div id="MediathekViewDLConfigPage" data-role="page" class="page type-interior pluginConfigurationPage"
     data-require="emby-input,emby-button,emby-select,emby-checkbox,emby-linkbutton">

    <div data-role="content">
        <div class="content-primary">
            <h1>MediathekViewDL</h1>
            <!-- Tab Navigation -->
            <div class="mvpl-tabs-spacer" role="tablist">
                <button type="button" class="paper-icon-button-light selected" id="mvpl-btn-tab-search" role="tab" aria-selected="true" aria-controls="tab-search">
                    <span class="material-icons search" aria-hidden="true"></span>
                    <span>Manuelle Suche</span>
                </button>
                <button type="button" class="paper-icon-button-light" id="mvpl-btn-tab-settings" role="tab" aria-selected="false" aria-controls="tab-settings">
                    <span class="material-icons settings" aria-hidden="true"></span>
                    <span>Einstellungen</span>
                </button>
                <button type="button" class="paper-icon-button-light" id="mvpl-btn-tab-subscriptions" role="tab" aria-selected="false" aria-controls="tab-subscriptions">
                    <span class="material-icons subscriptions" aria-hidden="true"></span>
                    <span>Abo Verwaltung</span>
                </button>
                <button type="button" class="paper-icon-button-light" id="mvpl-btn-tab-downloads" role="tab" aria-selected="false" aria-controls="tab-downloads">
                    <span class="material-icons file_download" aria-hidden="true"></span>
                    <span>Downloads</span>
                </button>
            </div>

            <!-- TAB 1: Search -->
            <div id="tab-search" class="mvpl-tab-content" role="tabpanel" aria-labelledby="mvpl-btn-tab-search" style="display:block;">
                <div class="verticalSection">
                    <div class="sectionTitleLabel">Mediathek durchsuchen</div>
                    <p class="sectionDescription">Suche nach Inhalten, um diese direkt herunterzuladen oder ein Abo
                        zu erstellen.</p>

                    <form id="mvpl-form-search">
                        <div class="mvpl-search-form-row">
                            <div class="inputContainer flex-grow">
                                <label class="inputLabel" for="txtSearchQuery">Suchbegriff</label>
                                <input is="emby-input" type="text" id="txtSearchQuery" required/>
                            </div>
                            <div class="inputContainer mvpl-input-short">
                                <label class="inputLabel" for="numMinDuration">Min. Dauer (Sek)</label>
                                <input is="emby-input" type="number" id="numMinDuration"/>
                            </div>
                            <div class="inputContainer mvpl-input-short">
                                <label class="inputLabel" for="numMaxDuration">Max. Dauer (Sek)</label>
                                <input is="emby-input" type="number" id="numMaxDuration"/>
                            </div>
                            <div class="inputContainer">
                                <button is="emby-button" type="submit" class="raised button-submit block">
                                    <span>Suchen</span>
                                </button>
                            </div>
                        </div>
                    </form>

                    <div id="searchResults" class="mvpl-results-container">
                        <!-- Ergebnisse werden hier gerendert -->
                    </div>
                </div>
            </div>

            <!-- TAB 2: Settings -->
            <div id="tab-settings" class="mvpl-tab-content" role="tabpanel" aria-labelledby="mvpl-btn-tab-settings" style="display:none;">
                <div class="verticalSection">
                    <div class="sectionTitleLabel">Allgemeine Einstellungen</div>
                    <form id="MediathekGeneralConfigForm">

                        <div class="inputContainer">
                            <div class="flex-align-center">
                                <div class="flex-grow">
                                    <label class="inputLabel" for="txtDefaultDownloadPath">Standard Download Pfad</label>
                                    <input is="emby-input" type="text" id="txtDefaultDownloadPath"/>
                                    <div class="fieldDescription">Der Standard-Ordner für alle Downloads, sofern im
                                        Abo nichts anderes definiert ist.
                                    </div>
                                </div>
                                <button type="button" is="paper-icon-button-light" id="btnSelectPath"
                                        title="Ordner auswählen" aria-label="Ordner auswählen" class="mvpl-folder-button">
                                    <span class="material-icons folder_open"></span>
                                </button>
                            </div>
                        </div>

                        <div class="checkboxContainer checkboxContainer-withDescription mvpl-margin-top-20">
                            <label class="emby-checkbox-label">
                                <input id="chkDownloadSubtitles" type="checkbox" is="emby-checkbox"/>
                                <span>Untertitel herunterladen (wenn verfügbar)</span>
                            </label>
                            <div class="fieldDescription">Lädt eine separate VTT- oder TTML-Datei für Untertitel
                                herunter, falls vom Sender bereitgestellt.
                            </div>
                        </div>

                        <div class="checkboxContainer checkboxContainer-withDescription mvpl-margin-top-20">
                            <label class="emby-checkbox-label">
                                <input id="chkAllowUnknownDomains" type="checkbox" is="emby-checkbox"/>
                                <span>Downloads von unbekannten Domains erlauben</span>
                            </label>
                            <div class="fieldDescription">Ermöglicht das Herunterladen von Inhalten von Domains,
                                die
                                nicht auf der Whitelist stehen. Dies kann nützlich sein, wenn ARD oder ZDF neue CDNs
                                hinzufügen, die noch nicht berücksichtigt werden. Dies kann jedoch ein
                                Sicherheitsrisiko darstellen, daher mit Vorsicht verwenden. Falls dadurch manche
                                Inhalte nicht gefunden werden wäre es schön, wenn auf GitHub ein Issue erstellt wird,
                                das ich die Whitelist ggf. erweitern kann.
                            </div>
                        </div>

                        <div class="checkboxContainer checkboxContainer-withDescription mvpl-margin-top-20">
                            <label class="emby-checkbox-label">
                                <input id="chkScanLibraryAfterDownload" type="checkbox" is="emby-checkbox"/>
                                <span>Bibliotheks-Scan nach Download</span>
                            </label>
                            <div class="fieldDescription">Startet automatisch einen Scan der Medienbibliothek, nachdem neue Inhalte heruntergeladen wurden. Wenn deaktiviert, erscheinen neue Inhalte erst nach dem nächsten regulären Scan.</div>
                        </div>

                        <div class="checkboxContainer checkboxContainer-withDescription mvpl-margin-top-20">
                            <label class="emby-checkbox-label">
                                <input id="chkEnableStrmCleanup" type="checkbox" is="emby-checkbox"/>
                                <span>Bereinigung ungültiger Streaming-Dateien (.strm) aktivieren</span>
                            </label>
                            <div class="fieldDescription">Überprüft regelmäßig (via geplanten Task) alle erstellten .strm Dateien auf Gültigkeit der Links. Wenn ein Link nicht mehr erreichbar ist (z.B. 404), wird die Datei gelöscht, damit ggf. eine aktualisierte Version heruntergeladen werden kann. Beachtet die Einstellung "Downloads von unbekannten Domains erlauben".</div>
                        </div>

                        <div class="inputContainer">
                            <label class="inputLabel" for="txtMinFreeDiskSpaceMiB">Mindestfreier Speicherplatz
                                (MiB)</label>
                            <input is="emby-input" type="number" id="txtMinFreeDiskSpaceMiB"/>
                            <div class="fieldDescription">Legt den minimalen freien Speicherplatz fest, der erforderlich ist, um einen neuen Download zu starten.</div>
                        </div>

                        <div class="inputContainer">
                            <label class="inputLabel" for="txtMaxBandwidthMBits">Maximale Download-Bandbreite (MBit/s)</label>
                            <input is="emby-input" type="number" id="txtMaxBandwidthMBits"/>
                            <div class="fieldDescription">Begrenzt die Download-Geschwindigkeit. 0 bedeutet unbegrenzt.</div>
                        </div>

                        <div class="inputContainer">
                            <label class="inputLabel">Letzter Lauf</label>
                            <div id="lblLastRun" class="mvpl-last-run-label">Noch nie</div>
                        </div>

                        <div>
                            <button is="emby-button" type="submit" class="raised button-submit block">
                                <span>Speichern</span>
                            </button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- TAB 3: Subscription Management -->
            <div id="tab-subscriptions" class="mvpl-tab-content" role="tabpanel" aria-labelledby="mvpl-btn-tab-subscriptions" style="display:none;">
                <div class="verticalSection">
                    <div class="flex-space-between">
                        <div class="sectionTitleLabel">Aktive Abonnements</div>
                        <button is="emby-button" type="button" class="raised" id="mvpl-btn-new-sub">
                            <span class="material-icons add"></span>
                            <span>Neues Abo</span>
                        </button>
                    </div>
                    <div id="subscriptionList" class="paperList mvpl-margin-top-20">
                        <!-- Liste wird hier gerendert -->
                    </div>
                </div>

                <!-- Modal/Bereich zum Editieren eines Abos (Initial versteckt) -->
                <div id="subscriptionEditor" class="mvpl-subscription-editor">
                    <h3 id="subEditorTitle">Abonnement bearbeiten</h3>
                    <form id="mvpl-form-subscription">
                        <input type="hidden" id="subId"/>

                        <div class="inputContainer">
                            <label class="inputLabel" for="subName">Name (Serienname)</label>
                            <input is="emby-input" type="text" id="subName" required/>
                        </div>

                        <!-- Container für dynamische Queries -->
                        <div class="inputContainer">
                            <label class="inputLabel">Suchanfragen</label>
                            <div id="queriesContainer" class="mvpl-queries-container">
                                <!-- Query-Zeilen werden hier dynamisch eingefügt -->
                            </div>
                            <button is="emby-button" type="button" class="raised mvpl-margin-top-10" id="mvpl-btn-add-query">
                                <span class="material-icons add"></span>
                                <span>Anfrage hinzufügen</span>
                            </button>
                        </div>

                        <div class="mvpl-duration-inputs-row">
                            <div class="inputContainer flex-grow">
                                <label class="inputLabel" for="subMinDuration">Min. Dauer (Minuten)</label>
                                <input is="emby-input" type="number" id="subMinDuration"/>
                            </div>
                            <div class="inputContainer flex-grow">
                                <label class="inputLabel" for="subMaxDuration">Max. Dauer (Minuten)</label>
                                <input is="emby-input" type="number" id="subMaxDuration"/>
                            </div>
                        </div>

                        <div class="inputContainer">
                            <div class="flex-align-center">
                                <div class="flex-grow">
                                    <label class="inputLabel" for="subPath">Download Pfad (Optional)</label>
                                    <input is="emby-input" type="text" id="subPath"/>
                                    <div class="fieldDescription">Leer lassen, um den Standardpfad zu nutzen.</div>
                                </div>
                                <button type="button" is="paper-icon-button-light" id="btnSelectSubPath"
                                        title="Ordner auswählen" aria-label="Ordner auswählen" class="mvpl-folder-button">
                                    <span class="material-icons folder_open"></span>
                                </button>
                            </div>
                        </div>

                        <!-- Enforce Series Parsing Checkbox -->
                        <div class="checkboxContainer checkboxContainer-withDescription">
                            <label class="emby-checkbox-label">
                                <input id="subEnforceSeries" type="checkbox" is="emby-checkbox"/>
                                <span>Nur Serien herunterladen</span>
                            </label>
                            <div class="fieldDescription">Nur Videos herunterladen, die als Serie erkannt werden
                            </div>
                        </div>

                        <!-- Allow Absolute Episode Numbering Checkbox -->
                        <div id="subAllowAbsoluteEpisodeNumberingContainer" class="checkboxContainer checkboxContainer-withDescription mvpl-indented-block">
                            <label class="emby-checkbox-label">
                                <input id="subAllowAbsoluteEpisodeNumbering" type="checkbox" is="emby-checkbox"/>
                                <span>Absolute Episodennummerierung erlauben</span>
                            </label>
                            <div class="fieldDescription">Episoden auch herunterladen, wenn nur Absolute
                                Episodennummerierung vorliegt (z.B. "Episode 5" statt "Staffel 1, Episode 5"). Wird
                                nur berücksichtigt, wenn "Nur Videos herunterladen, die als Serie erkannt werden"
                                aktiviert ist.
                            </div>
                        </div>

                        <!-- Create NFO Checkbox -->
                        <div class="checkboxContainer checkboxContainer-withDescription">
                            <label class="emby-checkbox-label">
                                <input id="subCreateNfo" type="checkbox" is="emby-checkbox"/>
                                <span>NFO Dateien erstellen</span>
                            </label>
                            <div class="fieldDescription">Erstellt eine .nfo Datei mit Metadaten (Beschreibung, Episodennummer) neben der Videodatei.</div>
                        </div>

                        <!-- Use Streaming-URL Files Checkbox -->
                        <div id="subUseStreamingUrlFilesContainer" class="checkboxContainer checkboxContainer-withDescription">
                            <label class="emby-checkbox-label">
                                <input id="subUseStreamingUrlFiles" type="checkbox" is="emby-checkbox"/>
                                <span>Streaming-URL-Dateien (.strm) verwenden</span>
                            </label>
                            <div class="fieldDescription">Verwendet Streaming-URL-Dateien (.strm) anstelle des
                                Herunterladens der tatsächlichen Videodateien. Es werden keine Videodateien
                                gespeichert, die Videos werden von ARD/ZDF direkt gestreamt. Untertitel sind hiervon nicht betroffen.
                            </div>
                        </div>

                        <!-- Full Video for Secondary Audio Checkbox -->
                        <div id="subDownloadFullVideoForSecondaryAudioContainer" class="checkboxContainer checkboxContainer-withDescription">
                            <label class="emby-checkbox-label">
                                <input id="subDownloadFullVideoForSecondaryAudio" type="checkbox" is="emby-checkbox"/>
                                <span>Vollständiges Video für sekundäre Audiosprachen herunterladen</span>
                            </label>
                            <div class="fieldDescription">Wenn aktiviert, wird das vollständige Video heruntergeladen, auch wenn es eine andere Audiosprache als Deutsch enthält. Andernfalls wird nur die Audiospur dieser Sprache extrahiert.</div>
                        </div>

                        <!-- Treat Non-Episodes as Extras Checkbox -->
                        <div id="subTreatNonEpisodesAsExtrasContainer" class="checkboxContainer checkboxContainer-withDescription">
                            <label class="emby-checkbox-label">
                                <input id="subTreatNonEpisodesAsExtras" type="checkbox" is="emby-checkbox"/>
                                <span>Nicht Episoden als Extras behandeln</span>
                            </label>
                            <div class="fieldDescription">Nicht als Episoden erkannte Videos als Extras behandeln.
                                Wird ignoriert, wenn "Nur Serien herunterladen" aktiviert ist.
                            </div>
                        </div>

                        <!-- Container for Extras Saving Options -->
                        <div class="mvpl-indented-block">
                            <!-- Save Extras as .strm Checkbox -->
                            <div id="subSaveExtrasAsStrmContainer" class="checkboxContainer checkboxContainer-withDescription">
                                <label class="emby-checkbox-label">
                                    <input id="subSaveExtrasAsStrm" type="checkbox" is="emby-checkbox"/>
                                    <span>Extras als Stream (.strm) speichern</span>
                                </label>
                                <div class="fieldDescription">Extras werden als .strm Dateien gespeichert (spart Speicherplatz).</div>
                            </div>

                            <!-- Save Trailers Checkbox -->
                            <div id="subSaveTrailersContainer" class="checkboxContainer checkboxContainer-withDescription">
                                <label class="emby-checkbox-label">
                                    <input id="subSaveTrailers" type="checkbox" is="emby-checkbox"/>
                                    <span>Trailer speichern</span>
                                </label>
                                <div class="fieldDescription">Trailer werden gespeichert.</div>
                            </div>

                            <!-- Save Interviews Checkbox -->
                            <div id="subSaveInterviewsContainer" class="checkboxContainer checkboxContainer-withDescription">
                                <label class="emby-checkbox-label">
                                    <input id="subSaveInterviews" type="checkbox" is="emby-checkbox"/>
                                    <span>Interviews speichern</span>
                                </label>
                                <div class="fieldDescription">Interviews werden gespeichert.</div>
                            </div>

                            <!-- Save Generic Extras Checkbox -->
                            <div id="subSaveGenericExtrasContainer" class="checkboxContainer checkboxContainer-withDescription">
                                <label class="emby-checkbox-label">
                                    <input id="subSaveGenericExtras" type="checkbox" is="emby-checkbox"/>
                                    <span>Generische Extras speichern</span>
                                </label>
                                <div class="fieldDescription">Alle anderen Extras (nicht Trailer/Interviews) werden gespeichert.</div>
                            </div>
                        </div>

                        <!-- Allow Audio Description Checkbox -->
                        <div class="checkboxContainer checkboxContainer-withDescription">
                            <label class="emby-checkbox-label">
                                <input id="subAllowAudioDesc" type="checkbox" is="emby-checkbox"/>
                                <span>Versionen mit Audiodeskription herunterladen</span>
                            </label>
                            <div class="fieldDescription">Lädt auch Inhalte mit Audiodeskription herunter (sofern verfügbar).
                            </div>
                        </div>

                        <!-- Allow Sign Language Checkbox -->
                        <div class="checkboxContainer checkboxContainer-withDescription">
                            <label class="emby-checkbox-label">
                                <input id="subAllowSignLanguage" type="checkbox" is="emby-checkbox"/>
                                <span>Versionen mit Gebärdensprache herunterladen</span>
                            </label>
                            <div class="fieldDescription">Lädt auch Inhalte mit Gebärdensprache herunter. (sofern verfügbar).
                            </div>
                        </div>

                        <!-- Enhanced Duplicate Detection Checkbox -->
                        <div class="checkboxContainer checkboxContainer-withDescription">
                            <label class="emby-checkbox-label">
                                <input id="subEnhancedDuplicateDetection" type="checkbox" is="emby-checkbox"/>
                                <span>Erweiterte Duplikaterkennung</span>
                            </label>
                            <div class="fieldDescription">Scannt das Zielverzeichnis nach vorhandenen Dateien mit passenden SxxExx-Mustern (oder absoluter Nummerierung), um doppelte Downloads zu vermeiden (auch bei abweichenden Dateinamen).</div>
                        </div>

                        <!-- Auto Upgrade Quality Checkbox -->
                        <div class="checkboxContainer checkboxContainer-withDescription">
                            <label class="emby-checkbox-label">
                                <input id="subAutoUpgradeToHigherQuality" type="checkbox" is="emby-checkbox"/>
                                <span>Automatisch auf höhere Qualität upgraden</span>
                            </label>
                            <div class="fieldDescription">Wenn aktiviert, werden bereits vorhandene Episoden durch eine Version mit höherer Auflösung ersetzt, falls verfügbar.</div>
                        </div>

                        <div class="checkboxContainer checkboxContainer-withDescription">
                            <label class="emby-checkbox-label">
                                <input id="subAllowFallbackToLowerQuality" type="checkbox" is="emby-checkbox"/>
                                <span>Fallback auf niedrigere Qualität erlauben</span>
                            </label>
                            <div class="fieldDescription">Wenn aktiviert, wird beim Herunterladen einer Episode geprüft, ob eine niedrigere Qualität verfügbar ist falls die HD-URL nicht gesetzt ist.</div>
                        </div>

                        <div id="subQualityCheckWithUrlContainer" class="checkboxContainer checkboxContainer-withDescription mvpl-indented-block">
                            <label class="emby-checkbox-label">
                                <input id="subQualityCheckWithUrl" type="checkbox" is="emby-checkbox"/>
                                <span>Prüft ob die URLs gültig ist.</span>
                            </label>
                            <div class="fieldDescription">Wenn aktiviert wird auch geprüft, ob die URLs von MediathekView noch verfügbar sind und ggf. die nächst niedrigere versucht. HD → Default → SD</div>
                        </div>

                        <div class="button-row">
                            <button is="emby-button" type="submit" class="raised button-submit">
                                <span>Abo Speichern</span>
                            </button>
                            <button is="emby-button" type="button" class="raised" id="mvpl-btn-test-sub">
                                <span>Abo prüfen (Dry Run)</span>
                            </button>
                            <button is="emby-button" type="button" class="raised button-cancel" id="mvpl-btn-cancel-sub">
                                <span>Abbrechen</span>
                            </button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- TAB 4: Downloads -->
            <div id="tab-downloads" class="mvpl-tab-content" role="tabpanel" aria-labelledby="mvpl-btn-tab-downloads" style="display:none;">
                <div class="verticalSection">
                    <div class="sectionTitleLabel">Aktive Downloads</div>
                    <p class="sectionDescription">Hier werden aktuell laufende und geplante Downloads angezeigt. Die Liste wird automatisch aktualisiert.</p>
                    <div id="activeDownloadsList" class="paperList mvpl-margin-top-20">
                        <!-- Liste der aktiven Downloads -->
                    </div>
                </div>
                <div class="verticalSection mvpl-margin-top-20">
                    <div class="sectionTitleLabel">Download Verlauf</div>
                    <p class="sectionDescription">Zuletzt erfolgreich abgeschlossene Downloads.</p>
                    <div id="downloadHistoryList" class="paperList mvpl-margin-top-20">
                        <!-- Liste des Verlaufs -->
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div id="testSubscriptionModal" class="mvpl-dialog-host">
        <div class="mvpl-dialog-content">
            <h2 id="testSubscriptionTitle" class="mvpl-modal-title">Test Ergebnisse</h2>
            <div id="testSubscriptionCount" class="mvpl-test-sub-count"></div>
            <div id="testSubscriptionResults" class="mvpl-test-sub-results">
                <!-- Ergebnisse werden hier gerendert -->
            </div>
            <div class="button-row">
                <button is="emby-button" type="button" class="raised button-cancel" id="mvpl-btn-close-test-results">
                    <span>Schließen</span>
                </button>
            </div>
        </div>
    </div>

    <div id="advancedDownloadModal" class="mvpl-dialog-host">
        <div class="mvpl-dialog-content">
            <h2 id="advancedDownloadTitle">Erweiterter Download</h2>
            <form id="mvpl-adv-download-form">
                <input type="hidden" id="advancedDownloadIndex"/>

                <div class="inputContainer">
                    <div class="flex-align-center">
                        <div class="flex-grow">
                            <label class="inputLabel" for="advDlPath">Download Pfad</label>
                            <input is="emby-input" type="text" id="advDlPath"/>
                        </div>
                        <button type="button" is="paper-icon-button-light" id="btnSelectAdvPath"
                                title="Ordner auswählen" aria-label="Ordner auswählen" class="mvpl-folder-button">
                            <span class="material-icons folder_open"></span>
                        </button>
                    </div>
                </div>

                <div class="inputContainer">
                    <label class="inputLabel" for="advDlFilename">Dateiname</label>
                    <input is="emby-input" type="text" id="advDlFilename"/>
                </div>

                <div class="checkboxContainer checkboxContainer-withDescription">
                    <label class="emby-checkbox-label">
                        <input id="advDlSubtitles" type="checkbox" is="emby-checkbox"/>
                        <span>Untertitel herunterladen</span>
                    </label>
                    <div id="advDlSubtitlesDesc" class="fieldDescription"></div>
                </div>

                <div class="button-row">
                    <button is="emby-button" type="submit" class="raised button-submit">
                        <span>Herunterladen</span>
                    </button>
                    <button is="emby-button" type="button" class="raised button-cancel" id="mvpl-btn-close-adv-download">
                        <span>Abbrechen</span>
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!--suppress JSUnusedGlobalSymbols -->
    <script type="text/javascript">
        (function () {
            /**
             * Helper class for DOM manipulation to reduce verbosity.
             */
            class DomHelper {
                /**
                 * Creates an HTML element with specified options.
                 * @param {string} tag - The HTML tag name.
                 * @param {Object} [options] - Options for the element.
                 * @param {string} [options.className] - CSS class names (space separated).
                 * @param {string} [options.text] - Text content.
                 * @param {string} [options.id] - Element ID.
                 * @param {Object} [options.attributes] - Key-value pair of attributes.
                 * @param {string} [options.type] - Input type (if tag is input/button).
                 * @param {string} [options.value] - Input value.
                 * @param {boolean} [options.checked] - Checkbox state.
                 * @param {Function} [options.onClick] - Click handler.
                 * @param {HTMLElement[]} [options.children] - Array of child elements to append.
                 * @returns {HTMLElement} The created element.
                 */
                create(tag, options = {}) {
                    const el = document.createElement(tag);
                    if (options.className) el.className = options.className;
                    if (options.text) el.textContent = options.text;
                    if (options.id) el.id = options.id;
                    if (options.type) el.type = options.type;
                    if (options.value) el.value = options.value;
                    if (options.checked) el.checked = true;

                    if (options.attributes) {
                        for (const [key, val] of Object.entries(options.attributes)) {
                            el.setAttribute(key, val);
                        }
                    }

                    if (options.onClick) {
                        el.addEventListener('click', options.onClick);
                    }

                    if (options.children) {
                        options.children.forEach(child => {
                            if (child) el.appendChild(child);
                        });
                    }

                    return el;
                }

                createIconButton(icon, title, onClick, id, ariaLabel) {
                    const span = this.create('span', {
                        className: 'material-icons ' + icon,
                        attributes: {'aria-hidden': 'true'}
                    });

                    const btnOptions = {
                        type: 'button',
                        className: 'paper-icon-button-light',
                        attributes: {
                            'is': 'emby-button',
                            'title': title,
                            'aria-label': ariaLabel || title
                        },
                        onClick: onClick,
                        children: [span]
                    };
                    if (id) btnOptions.id = id;

                    return this.create('button', btnOptions);
                }

                createCheckbox(label, checked, options = {}) {
                    const {id, value, description, className, onChange} = options;

                    const inputOptions = {
                        type: 'checkbox',
                        checked: checked,
                        attributes: {'is': 'emby-checkbox'}
                    };
                    if (id) inputOptions.id = id;
                    if (value) inputOptions.value = value;
                    if (className) inputOptions.className = className;

                    const input = this.create('input', inputOptions);
                    if (onChange) input.addEventListener('change', onChange);

                    const span = this.create('span', {text: label});

                    const labelEl = this.create('label', {
                        className: 'emby-checkbox-label',
                        children: [input, span]
                    });

                    if (description) {
                        const descEl = this.create('div', {
                            className: 'fieldDescription',
                            text: description
                        });
                        return this.create('div', {
                            className: 'checkboxContainer checkboxContainer-withDescription',
                            children: [labelEl, descEl]
                        });
                    }

                    return labelEl;
                }
            }

            /**
             * Handles search operations.
             */
            class SearchController {
                constructor(config) {
                    this.config = config;
                    this.dom = config.dom;
                    this.currentSearchResults = [];
                }

                init() {
                    document.getElementById('mvpl-form-search').addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.performSearch();
                        return false;
                    });
                }

                performSearch() {
                    const query = document.getElementById('txtSearchQuery').value;
                    const minD = document.getElementById('numMinDuration').value;
                    const maxD = document.getElementById('numMaxDuration').value;

                    if (!query) {
                        this.config.showToast("Bitte Suchbegriff eingeben");
                        return;
                    }
                    // noinspection JSUnresolvedReference
                    Dashboard.showLoadingMsg();
                    // noinspection JSUnresolvedReference
                    let url = ApiClient.getUrl('/' + this.config.pluginName + '/Search');
                    url += '?query=' + encodeURIComponent(query);
                    if (minD) url += '&minDuration=' + minD;
                    if (maxD) url += '&maxDuration=' + maxD;
                    // noinspection JSUnresolvedReference
                    ApiClient.getJSON(url).then((results) => {
                        this.currentSearchResults = results;
                        this.renderSearchResults();
                        // noinspection JSUnresolvedReference
                        Dashboard.hideLoadingMsg();
                    }).catch((err) => {
                        // noinspection JSUnresolvedReference
                        Dashboard.hideLoadingMsg();
                        this.config.showToast("Fehler bei der Suche: " + err);
                    });
                }

                renderSearchResults() {
                    const container = document.getElementById('searchResults');
                    container.textContent = "";

                    if (!this.currentSearchResults || this.currentSearchResults.length === 0) {
                        const noRes = document.createElement('p');
                        noRes.textContent = "Keine Ergebnisse gefunden.";
                        container.appendChild(noRes);
                        return;
                    }

                    const paperList = document.createElement('div');
                    paperList.classList.add('paperList');

                    this.currentSearchResults.forEach((item, index) => {
                        paperList.appendChild(this.createSearchResultItem(item, index));
                    });
                    container.appendChild(paperList);
                }

                createSearchResultItem(item, index) {
                    const durationStr = Math.floor(item.duration / 60) + " Min";
                    const actions = document.createElement('div');
                    actions.classList.add('flex-gap-10');

                    actions.appendChild(this.dom.createIconButton('file_download', 'Herunterladen', () => this.downloadItem(index)));
                    actions.appendChild(this.dom.createIconButton('settings', 'Erweiterter Download', () => this.config.openAdvancedDownloadDialog(this.currentSearchResults[index])));
                    actions.appendChild(this.dom.createIconButton('add', 'Abo erstellen', () => this.createSubFromSearch(null, item.title, item.channel, item.topic)));

                    // Build BodyText1
                    const body1 = document.createElement('div');
                    body1.classList.add('flex-align-center');
                    body1.style.gap = '8px';
                    const textSpan = document.createElement('span');
                    textSpan.textContent = item.channel + ' | ' + item.topic + ' | ' + durationStr;
                    body1.appendChild(textSpan);

                    if (item.url_subtitle) {
                        const sep = document.createElement('span');
                        sep.textContent = ' | ';
                        body1.appendChild(sep);
                        const icon = document.createElement('span');
                        icon.classList.add('material-icons', 'closed_caption');
                        icon.title = 'Untertitel verfügbar';
                        body1.appendChild(icon);
                    }

                    const bodyText2 = item.description || '';

                    return this.config.createListItem(item.title, body1, bodyText2, actions);
                }

                downloadItem(index) {
                    const item = this.currentSearchResults[index];
                    if (!item) return;
                    // noinspection JSUnresolvedReference
                    const url = ApiClient.getUrl('/' + this.config.pluginName + '/Download');
                    // noinspection JSUnresolvedReference
                    Dashboard.showLoadingMsg();
                    // noinspection JSUnresolvedReference
                    ApiClient.ajax({
                        type: "POST",
                        url: url,
                        data: JSON.stringify(item),
                        contentType: 'application/json'
                    }).then((result) => {
                        // noinspection JSUnresolvedReference
                        Dashboard.hideLoadingMsg();
                        this.config.showToast("Download für '" + item.title + "' in Warteschlange.");
                    }).catch((err) => {
                        // noinspection JSUnresolvedReference
                        Dashboard.hideLoadingMsg();
                        this.config.showToast("Fehler beim Starten des Downloads: " + (err.responseJSON ? err.responseJSON.detail : "Unbekannter Fehler"));
                    });
                }

                createSubFromSearch(btn, title, channel, topic) {
                    this.config.switchTab('subscriptions');
                    const newSub = {
                        Id: null,
                        Name: topic,
                        Queries: [
                            {fields: ["title"], query: title},
                            {fields: ["channel"], query: channel},
                            {fields: ["topic"], query: topic}
                        ],
                        MinDurationMinutes: null,
                        MaxDurationMinutes: null,
                        DownloadPath: "",
                        EnforceSeriesParsing: false,
                        AllowAudioDescription: false
                    };
                    this.config.subscriptionEditor.show(newSub);
                }
            }

            class DownloadsController {
                constructor(config) {
                    this.config = config;
                    this.dom = config.dom;
                    this.pollInterval = null;
                    this.statusMapping = {
                        'Queued': { text: 'Warteschlange' }, // Queued
                        'Downloading': { text: 'Herunterladen...' }, // Downloading
                        'Processing': { text: 'Verarbeiten...'}, // Processing
                        'Finished': { text: 'Fertig'}, // Finished
                        'Failed': { text: 'Fehler' }, // Failed
                        'Cancelled': { text: 'Abgebrochen' } // Cancelled
                    };
                }

                init() {
                    // Initial load handled by switchTab
                }

                startPolling() {
                    this.stopPolling();
                    this.refreshData();
                    this.pollInterval = setInterval(() => this.refreshData(), 3000);
                }

                stopPolling() {
                    if (this.pollInterval) {
                        clearInterval(this.pollInterval);
                        this.pollInterval = null;
                    }
                }

                refreshData() {
                    this.fetchActive();
                    this.fetchHistory();
                }

                fetchActive() {
                    const url = ApiClient.getUrl('/' + this.config.pluginName + '/Downloads/Active');
                    ApiClient.getJSON(url).then((downloads) => {
                        this.renderActive(downloads);
                    }).catch((err) => {
                        console.error("Error fetching active downloads", err);
                    });
                }

                fetchHistory() {
                    const url = ApiClient.getUrl('/' + this.config.pluginName + '/Downloads/History?limit=20');
                    ApiClient.getJSON(url).then((history) => {
                        this.renderHistory(history);
                    }).catch((err) => {
                        console.error("Error fetching download history", err);
                    });
                }

                renderActive(downloads) {
                    const container = document.getElementById('activeDownloadsList');
                    container.textContent = "";

                    if (!downloads || downloads.length === 0) {
                        const noRes = document.createElement('p');
                        noRes.textContent = "Keine aktiven Downloads.";
                        container.appendChild(noRes);
                        return;
                    }

                    downloads.forEach((dl) => {
                        const statusInfo = this.statusMapping[dl.Status] || { text: 'Unbekannt' };
                        const progress = dl.Status === 'Downloading' ?  Math.round(dl.Progress || 0) + '%' : '-';

                        const actions = document.createElement('div');
                        actions.classList.add('flex-gap-10');

                        // Show cancel button only if not finished/failed/cancelled
                        if (['Queued', 'Downloading', 'Processing'].includes(dl.Status) ) {
                             actions.appendChild(this.dom.createIconButton('cancel', 'Abbrechen', () => this.cancelDownload(dl.Id)));
                        }

                        const statusBadge = document.createElement('span');
                        statusBadge.classList.add('mvpl-download-status');
                        statusBadge.setAttribute('data-status', dl.Status);
                        statusBadge.textContent = statusInfo.text;



                        const body1 = document.createElement('div');
                        body1.classList.add('flex-align-center');
                        body1.appendChild(document.createTextNode('Fortschritt: ' + progress));
                        body1.appendChild(statusBadge);

                        if (dl.ErrorMessage) {
                             const errorText = document.createElement('div');
                             errorText.style.color = '#F44336';
                             errorText.style.fontSize = '0.85em';
                             errorText.style.marginTop = '4px';
                             errorText.textContent = dl.ErrorMessage;
                             body1.appendChild(errorText);
                        }

                        const createdAt = new Date(dl.CreatedAt).toLocaleString();
                        const body2 = 'Hinzugefügt: ' + createdAt + (dl.SubscriptionId === '00000000-0000-0000-0000-000000000000' ? ' (Manuell)' : ' (Abo)');

                        container.appendChild(this.config.createListItem(dl.Job.Title, body1, body2, actions));
                    });
                }

                renderHistory(history) {
                    const container = document.getElementById('downloadHistoryList');
                    container.textContent = "";

                    if (!history || history.length === 0) {
                        const noRes = document.createElement('p');
                        noRes.textContent = "Kein Verlauf verfügbar.";
                        container.appendChild(noRes);
                        return;
                    }

                    history.forEach((entry) => {
                        const timestamp = new Date(entry.Timestamp).toLocaleString();
                        const body1 = 'Pfad: ' + entry.DownloadPath;
                        const body2 = 'Datum: ' + timestamp;

                        container.appendChild(this.config.createListItem(entry.ItemId, body1, body2, null));
                        // Wait, ItemId as Title is not great. ResultItem Title is better but not in history.
                        // Let's use the filename from the path as title.
                        const fileName = entry.DownloadPath.split(/[\\\/]/).pop();
                        container.lastChild.querySelector('.listItemBodyText').textContent = fileName;
                    });
                }

                cancelDownload(id) {
                    const url = ApiClient.getUrl('/' + this.config.pluginName + '/Downloads/' + id);
                    ApiClient.ajax({
                        type: "DELETE",
                        url: url
                    }).then(() => {
                        this.config.showToast("Abbruch angefordert.");
                        this.refreshData();
                    }).catch((err) => {
                        this.config.showToast("Fehler beim Abbrechen: " + (err.responseJSON ? err.responseJSON.detail : "Unbekannter Fehler"));
                    });
                }
            }

            /**
             * Manages UI dependencies (showing/hiding fields based on others).
             */
            class DependencyManager {
                constructor() {
                    this.rules = [
                        {
                            controllerId: 'subTreatNonEpisodesAsExtras',
                            dependentId: 'subSaveTrailersContainer',
                            showWhen: true,
                            disableWhenHidden: true
                        },
                        {
                            controllerId: 'subTreatNonEpisodesAsExtras',
                            dependentId: 'subSaveInterviewsContainer',
                            showWhen: true,
                            disableWhenHidden: true
                        },
                        {
                            controllerId: 'subTreatNonEpisodesAsExtras',
                            dependentId: 'subSaveGenericExtrasContainer',
                            showWhen: true,
                            disableWhenHidden: true
                        },
                        {
                            controllerId: 'subTreatNonEpisodesAsExtras',
                            dependentId: 'subSaveExtrasAsStrmContainer',
                            showWhen: true,
                            disableWhenHidden: true
                        },
                        {
                            controllerId: 'subEnforceSeries',
                            dependentId: 'subAllowAbsoluteEpisodeNumberingContainer',
                            showWhen: true,
                            disableWhenHidden: true
                        },
                        {
                            controllerId: 'subUseStreamingUrlFiles',
                            dependentId: 'subDownloadFullVideoForSecondaryAudioContainer',
                            showWhen: false,
                            disableWhenHidden: true
                        },
                        {
                            controllerId: 'subDownloadFullVideoForSecondaryAudio',
                            dependentId: 'subUseStreamingUrlFilesContainer',
                            showWhen: false,
                            disableWhenHidden: true
                        },
                        {
                            controllerId: 'subAllowFallbackToLowerQuality',
                            dependentId: 'subQualityCheckWithUrlContainer',
                            showWhen: true,
                            disableWhenHidden: true
                        }
                    ];
                }

                init() {
                    const controllerIds = [...new Set(this.rules.map(rule => rule.controllerId))];
                    controllerIds.forEach(id => {
                        const controller = document.getElementById(id);
                        if (controller) {
                            controller.addEventListener('change', () => this.applyDependencies());
                        }
                    });
                }

                applyDependencies() {
                    this.rules.forEach(rule => {
                        const controller = document.getElementById(rule.controllerId);
                        const dependentContainer = document.getElementById(rule.dependentId);

                        if (controller && dependentContainer) {
                            const shouldShow = controller.checked === rule.showWhen;

                            // Ensure the container has the base animation class
                            dependentContainer.classList.add('mvpl-animated-container');

                            if (shouldShow) {
                                dependentContainer.classList.remove('mvpl-hidden');
                            } else {
                                dependentContainer.classList.add('mvpl-hidden');
                            }

                            if (rule.disableWhenHidden && !shouldShow) {
                                const dependentInput = dependentContainer.querySelector('input[type="checkbox"]');
                                if (dependentInput) {
                                    dependentInput.checked = false;
                                }
                            }
                        }
                    });
                }
            }

            /**
             * Handles subscription editor logic, populating fields and gathering values.
             */
            class SubscriptionEditor {
                /**
                 * @param {MediathekPluginConfig} configInstance
                 */
                constructor(configInstance) {
                    this.config = configInstance;
                }

                /**
                 * Populates the editor form with values from a subscription object.
                 * @param {Object|null} sub - The subscription object or null for a new subscription.
                 */
                setEditorValues(sub) {
                    if (!sub) {
                        // Reset values
                        document.getElementById('subId').value = "";
                        document.getElementById('subName').value = "";
                        document.getElementById('subMinDuration').value = "";
                        document.getElementById('subMaxDuration').value = "";
                        document.getElementById('subPath').value = "";

                        document.getElementById('subEnforceSeries').checked = false;
                        document.getElementById('subCreateNfo').checked = false;
                        document.getElementById('subAllowAudioDesc').checked = false;
                        document.getElementById('subAllowAbsoluteEpisodeNumbering').checked = false;
                        document.getElementById('subAllowSignLanguage').checked = false;
                        document.getElementById('subTreatNonEpisodesAsExtras').checked = false;
                        document.getElementById('subSaveTrailers').checked = true;
                        document.getElementById('subSaveInterviews').checked = true;
                        document.getElementById('subSaveGenericExtras').checked = true;
                        document.getElementById('subSaveExtrasAsStrm').checked = false;
                        document.getElementById('subUseStreamingUrlFiles').checked = false;
                        document.getElementById('subDownloadFullVideoForSecondaryAudio').checked = false;
                        document.getElementById('subEnhancedDuplicateDetection').checked = false;
                        document.getElementById('subAutoUpgradeToHigherQuality').checked = false;
                        document.getElementById('subAllowFallbackToLowerQuality').checked = true;
                        document.getElementById('subQualityCheckWithUrl').checked = false;

                        document.getElementById('queriesContainer').textContent = '';
                        this.config.addQueryRow(null);

                        // Force update dependencies to hide unchecked dependent fields
                        this.config.dependencyManager.applyDependencies();
                        return;
                    }

                    document.getElementById('subId').value = sub.Id || "";
                    document.getElementById('subName').value = sub.Name;
                    document.getElementById('subMinDuration').value = sub.MinDurationMinutes || "";
                    document.getElementById('subMaxDuration').value = sub.MaxDurationMinutes || "";
                    document.getElementById('subPath').value = sub.DownloadPath || "";
                    document.getElementById('subEnforceSeries').checked = sub.EnforceSeriesParsing;
                    document.getElementById('subCreateNfo').checked = sub.CreateNfo !== undefined ? sub.CreateNfo : false;
                    document.getElementById('subAllowAudioDesc').checked = sub.AllowAudioDescription;
                    document.getElementById('subAllowAbsoluteEpisodeNumbering').checked = sub.AllowAbsoluteEpisodeNumbering;
                    document.getElementById('subAllowSignLanguage').checked = sub.AllowSignLanguage;
                    document.getElementById('subEnhancedDuplicateDetection').checked = sub.EnhancedDuplicateDetection;
                    document.getElementById('subAutoUpgradeToHigherQuality').checked = sub.AutoUpgradeToHigherQuality !== undefined ? sub.AutoUpgradeToHigherQuality : false;
                    document.getElementById('subTreatNonEpisodesAsExtras').checked = sub.TreatNonEpisodesAsExtras;
                    document.getElementById('subSaveTrailers').checked = sub.SaveTrailers;
                    document.getElementById('subSaveInterviews').checked = sub.SaveInterviews;
                    document.getElementById('subSaveGenericExtras').checked = sub.SaveGenericExtras;
                    document.getElementById('subSaveExtrasAsStrm').checked = sub.SaveExtrasAsStrm;
                    document.getElementById('subUseStreamingUrlFiles').checked = sub.UseStreamingUrlFiles;
                    document.getElementById('subDownloadFullVideoForSecondaryAudio').checked = sub.DownloadFullVideoForSecondaryAudio;
                    document.getElementById('subAllowFallbackToLowerQuality').checked = sub.AllowFallbackToLowerQuality !== undefined ? sub.AllowFallbackToLowerQuality : true;
                    document.getElementById('subQualityCheckWithUrl').checked = sub.QualityCheckWithUrl !== undefined ? sub.QualityCheckWithUrl : false;


                    const queriesContainer = document.getElementById('queriesContainer');
                    queriesContainer.textContent = '';
                    if (sub.Queries && sub.Queries.length > 0) {
                        sub.Queries.forEach((q) => {
                            this.config.addQueryRow(q);
                        });
                    } else {
                        this.config.addQueryRow(null);
                    }
                }

                /**
                 * Collects values from the editor form to create a subscription object.
                 * @returns {Object} The subscription object.
                 */
                getEditorValues() {
                    const id = document.getElementById('subId').value;
                    const name = document.getElementById('subName').value;
                    const minDuration = document.getElementById('subMinDuration').value;
                    const maxDuration = document.getElementById('subMaxDuration').value;
                    const path = document.getElementById('subPath').value;
                    const enforce = document.getElementById('subEnforceSeries').checked;
                    const createNfo = document.getElementById('subCreateNfo').checked;
                    const allowAudio = document.getElementById('subAllowAudioDesc').checked;
                    const allowAbsolute = document.getElementById('subAllowAbsoluteEpisodeNumbering').checked;
                    const allowSignLanguage = document.getElementById('subAllowSignLanguage').checked;
                    const enhancedDuplicateDetection = document.getElementById('subEnhancedDuplicateDetection').checked;
                    const autoUpgradeToHigherQuality = document.getElementById('subAutoUpgradeToHigherQuality').checked;
                    const treatNonEpisodesAsExtras = document.getElementById('subTreatNonEpisodesAsExtras').checked;
                    const saveTrailers = document.getElementById('subSaveTrailers').checked;
                    const saveInterviews = document.getElementById('subSaveInterviews').checked;
                    const saveGenericExtras = document.getElementById('subSaveGenericExtras').checked;
                    const saveExtrasAsStrm = document.getElementById('subSaveExtrasAsStrm').checked;
                    const useStreamingUrlFiles = document.getElementById('subUseStreamingUrlFiles').checked;
                    const downloadFullVideoForSecondaryAudio = document.getElementById('subDownloadFullVideoForSecondaryAudio').checked;
                    const allowFallbackToLowerQuality = document.getElementById('subAllowFallbackToLowerQuality').checked;
                    const qualityCheckWithUrl = document.getElementById('subQualityCheckWithUrl').checked;

                    const queries = [];
                    document.querySelectorAll('#queriesContainer .mvpl-query-row').forEach(function (row) {
                        const queryText = row.querySelector('.subQueryText').value;
                        if (queryText) {
                            const fields = [];
                            row.querySelectorAll('.subQueryField:checked').forEach(function (fieldCheckbox) {
                                fields.push(fieldCheckbox.value);
                            });
                            queries.push({query: queryText, fields: fields});
                        }
                    });

                    return {
                        Id: id,
                        Name: name,
                        Queries: queries,
                        MinDurationMinutes: minDuration ? parseInt(minDuration, 10) : null,
                        MaxDurationMinutes: maxDuration ? parseInt(maxDuration, 10) : null,
                        DownloadPath: path,
                        EnforceSeriesParsing: enforce,
                        CreateNfo: createNfo,
                        AllowAudioDescription: allowAudio,
                        AllowAbsoluteEpisodeNumbering: allowAbsolute,
                        AllowSignLanguage: allowSignLanguage,
                        EnhancedDuplicateDetection: enhancedDuplicateDetection,
                        AutoUpgradeToHigherQuality: autoUpgradeToHigherQuality,
                        TreatNonEpisodesAsExtras: treatNonEpisodesAsExtras,
                        SaveTrailers: saveTrailers,
                        SaveInterviews: saveInterviews,
                        SaveGenericExtras: saveGenericExtras,
                        SaveExtrasAsStrm: saveExtrasAsStrm,
                        UseStreamingUrlFiles: useStreamingUrlFiles,
                        DownloadFullVideoForSecondaryAudio: downloadFullVideoForSecondaryAudio,
                        AllowFallbackToLowerQuality: allowFallbackToLowerQuality,
                        QualityCheckWithUrl: qualityCheckWithUrl,
                    };
                }

                /**
                 * Opens the subscription editor modal.
                 * @param {Object|null} sub - The subscription to edit or null for new.
                 * @param {string|null} titleText - Optional title override.
                 */
                show(sub, titleText) {
                    const editor = document.getElementById('subscriptionEditor');
                    const title = document.getElementById('subEditorTitle');

                    if (titleText) {
                        title.innerText = titleText;
                    } else {
                        title.innerText = sub ? "Abonnement bearbeiten" : "Neues Abonnement erstellen";
                    }

                    this.setEditorValues(sub);
                    this.config.dependencyManager.applyDependencies();

                    editor.style.display = 'block';
                    editor.scrollIntoView({behavior: 'smooth'});
                }

                /**
                 * Closes the subscription editor modal.
                 */
                close() {
                    document.getElementById('subscriptionEditor').style.display = 'none';
                }
            }

            /**
             * Main configuration class for the plugin.
             */
            class MediathekPluginConfig {
                constructor() {
                    this.pluginId = "a31b415a-5264-419d-b152-8c8192a54994";
                    this.pluginName = "MediathekViewDL";
                    this.dom = new DomHelper();
                    this.searchController = new SearchController(this);
                    this.downloadsController = new DownloadsController(this);
                    this.dependencyManager = new DependencyManager();
                    this.currentConfig = null;
                    this.currentItemForAdvancedDl = null;
                    this.subscriptionEditor = new SubscriptionEditor(this);
                }

                // --- Helper Functions ---

                confirmationPopup(message, title, resultCallback) {
                    // noinspection JSUnresolvedReference
                    if (typeof Dashboard !== 'undefined' && typeof Dashboard.confirm === 'function') {
                        // noinspection JSUnresolvedReference,JSCheckFunctionSignatures
                        Dashboard.confirm(message, title, resultCallback);
                    } else {
                        const result = confirm(title + "\n\n" + message);
                        resultCallback(result);
                    }
                }

                showToast(message) {
                    // noinspection JSUnresolvedReference
                    if (typeof Dashboard !== 'undefined' && typeof Dashboard.alert === 'function') {
                        // noinspection JSUnresolvedReference
                        Dashboard.alert(message);
                    } else {
                        alert(message);
                    }
                }

                openFolderDialog(inputId, headerText) {
                    try {
                        // noinspection JSUnresolvedReference
                        if (typeof Dashboard !== 'undefined' && Dashboard.DirectoryBrowser) {
                            // noinspection JSUnresolvedReference
                            const picker = new Dashboard.DirectoryBrowser();
                            picker.show({
                                header: headerText,
                                includeDirectories: true,
                                includeFiles: false,
                                callback: (path) => {
                                    if (path) {
                                        document.getElementById(inputId).value = path;
                                    }
                                    picker.close();
                                }
                            });
                        } else {
                            let currentValue = document.getElementById(inputId).value;
                            let newPath = prompt(headerText + '\nAktueller Pfad: ' + currentValue, currentValue);
                            if (newPath !== null && newPath.trim() !== '') {
                                document.getElementById(inputId).value = newPath.trim();
                            }
                        }
                    } catch (e) {
                        console.error('Error opening folder dialog:', e);
                        let currentValue = document.getElementById(inputId).value;
                        let newPath = prompt(headerText + '\nAktueller Pfad: ' + currentValue, currentValue);
                        if (newPath !== null && newPath.trim() !== '') {
                            document.getElementById(inputId).value = newPath.trim();
                        }
                    }
                }

                genUUID() {
                    try {
                        return crypto.randomUUID();
                    } catch (e) {
                        console.error('Error generating UUID using crypto.randomUUID():', e);
                    }
                    console.warn('Falling back to manual UUID generation.');
                    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                        let r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                        return v.toString(16);
                    });
                }

                // --- Core Logic ---

                /**
                 * Loads the configuration from the server.
                 */
                loadConfig() {
                    // noinspection JSUnresolvedReference
                    Dashboard.showLoadingMsg();
                    // noinspection JSUnresolvedReference
                    ApiClient.getPluginConfiguration(this.pluginId).then((config) => {
                        this.currentConfig = config;

                        document.querySelector('#txtDefaultDownloadPath').value = config.DefaultDownloadPath || "";
                        document.querySelector('#chkDownloadSubtitles').checked = config.DownloadSubtitles;
                        document.querySelector('#chkAllowUnknownDomains').checked = config.AllowUnknownDomains;
                        document.querySelector('#chkScanLibraryAfterDownload').checked = config.ScanLibraryAfterDownload;
                        document.querySelector('#chkEnableStrmCleanup').checked = config.EnableStrmCleanup;
                        document.querySelector('#txtMinFreeDiskSpaceMiB').value = config.MinFreeDiskSpaceBytes ? (config.MinFreeDiskSpaceBytes / (1024 * 1024)) : "";
                        document.querySelector('#txtMaxBandwidthMBits').value = config.MaxBandwidthMBits || 0;
                        document.querySelector('#lblLastRun').innerText = config.LastRun ? new Date(config.LastRun).toLocaleString() : "Noch nie";

                        this.renderSubscriptionsList();
                        // noinspection JSUnresolvedReference
                        Dashboard.hideLoadingMsg();
                    });
                }

                /**
                 * Saves the global configuration to the server.
                 */
                saveGlobalConfig() {
                    // noinspection JSUnresolvedReference
                    Dashboard.showLoadingMsg();
                    // noinspection JSUnresolvedReference
                    ApiClient.updatePluginConfiguration(this.pluginId, this.currentConfig).then((result) => {
                        // noinspection JSUnresolvedReference
                        Dashboard.processPluginConfigurationUpdateResult(result);
                        this.showToast("Einstellungen gespeichert.");
                        this.loadConfig();
                    });
                }

                /**
                 * Switches the visible tab.
                 * @param {string} tabId - The ID suffix of the tab to show ('search', 'settings', 'subscriptions').
                 */
                switchTab(tabId) {
                    document.querySelectorAll('.mvpl-tab-content').forEach(el => el.style.display = 'none');
                    document.getElementById('tab-' + tabId).style.display = 'block';

                    const buttons = document.querySelectorAll('.mvpl-tabs-spacer button');
                    buttons.forEach(btn => {
                        btn.classList.remove('selected');
                        btn.setAttribute('aria-selected', 'false');
                    });

                    const selectedBtn = document.getElementById('mvpl-btn-tab-' + tabId);
                    if (selectedBtn) {
                        selectedBtn.classList.add('selected');
                        selectedBtn.setAttribute('aria-selected', 'true');
                    }

                    if (tabId === 'downloads') {
                        this.downloadsController.startPolling();
                    } else {
                        this.downloadsController.stopPolling();
                    }
                }

                // --- SEARCH LOGIC ---

                createListItem(title, bodyText1, bodyText2, actions) {
                    const listItem = document.createElement('div');
                    listItem.classList.add('listItem', 'listItem-border');

                    const body = document.createElement('div');
                    body.classList.add('listItemBody', 'two-line');

                    const titleEl = document.createElement('h3');
                    titleEl.classList.add('listItemBodyText');
                    titleEl.textContent = title;

                    const text1El = document.createElement('div');
                    text1El.classList.add('listItemBodyText', 'secondary');
                    if (typeof bodyText1 === 'string') {
                        text1El.textContent = bodyText1;
                    } else if (bodyText1 instanceof Node) {
                        text1El.appendChild(bodyText1);
                    }

                    const text2El = document.createElement('div');
                    text2El.classList.add('listItemBodyText', 'secondary');
                    if (typeof bodyText2 === 'string') {
                        text2El.textContent = bodyText2;
                    } else if (bodyText2 instanceof Node) {
                        text2El.appendChild(bodyText2);
                    }

                    body.appendChild(titleEl);
                    body.appendChild(text1El);
                    body.appendChild(text2El);

                    listItem.appendChild(body);

                    if (actions) {
                        listItem.appendChild(actions);
                    }

                    return listItem;
                }


                // ---SUBSCRIPTION LOGIC ---
                renderSubscriptionsList() {
                    const list = document.getElementById('subscriptionList');
                    list.textContent = "";

                    if (!this.currentConfig.Subscriptions || this.currentConfig.Subscriptions.length === 0) {
                        const noSubs = document.createElement('p');
                        noSubs.textContent = "Keine aktiven Abonnements.";
                        list.appendChild(noSubs);
                        return;
                    }

                    this.currentConfig.Subscriptions.forEach((sub) => {
                        // Handle IsEnabled default true if undefined
                        if (sub.IsEnabled === undefined) sub.IsEnabled = true;

                        const queriesSummary = (sub.Queries || []).map(function (q) {
                            return q.query;
                        }).join(', ');
                        const lastDownloadText = sub.LastDownloadedTimestamp ? new Date(sub.LastDownloadedTimestamp).toLocaleString() : "Nie";

                        const actions = document.createElement('div');
                        actions.classList.add('flex-gap-5');

                        // Toggle Button
                        const toggleIcon = sub.IsEnabled ? 'pause_circle_outline' : 'play_circle_outline';
                        const toggleTitle = sub.IsEnabled ? 'Deaktivieren' : 'Aktivieren';
                        actions.appendChild(this.dom.createIconButton(toggleIcon, toggleTitle, () => this.toggleSubscription(sub.Id)));

                        actions.appendChild(this.dom.createIconButton('refresh', 'Verarbeitete Items zurücksetzen', () => this.resetProcessedItems(sub.Id)));
                        actions.appendChild(this.dom.createIconButton('edit', 'Bearbeiten', () => this.subscriptionEditor.show(sub)));
                        actions.appendChild(this.dom.createIconButton('delete', 'Löschen', () => this.deleteSubscription(sub.Id)));

                        // Add Status to title
                        const statusText = sub.IsEnabled ? "" : " (Deaktiviert)";
                        const title = sub.Name + statusText;
                        const bodyText1 = 'Queries: ' + queriesSummary;
                        const bodyText2 = 'Letzter Download: ' + lastDownloadText;

                        const listItem = this.createListItem(title, bodyText1, bodyText2, actions);

                        // Visual cue for disabled state
                        if (!sub.IsEnabled) {
                            listItem.classList.add('sub-disabled');
                        }

                        list.appendChild(listItem);
                    });
                }

                toggleSubscription(id) {
                    const idx = this.currentConfig.Subscriptions.findIndex(function (s) {
                        return s.Id === id;
                    });
                    if (idx > -1) {
                        // Toggle
                        if (this.currentConfig.Subscriptions[idx].IsEnabled === undefined) {
                            this.currentConfig.Subscriptions[idx].IsEnabled = false; // Was true (implicit), now false
                        } else {
                            this.currentConfig.Subscriptions[idx].IsEnabled = !this.currentConfig.Subscriptions[idx].IsEnabled;
                        }

                        this.saveGlobalConfig();
                    }
                }

                resetProcessedItems(id) {
                    this.confirmationPopup("Dies wird die Liste der bereits verarbeiteten Items für dieses Abonnement zurücksetzen. Es kann dazu führen, dass bereits heruntergeladene Inhalte erneut heruntergeladen werden, wenn sie noch in den Suchergebnissen der MediathekView API erscheinen. Fortfahren?", "Verarbeitete Items zurücksetzen", (confirmed) => {
                        if (confirmed) {
                            // noinspection JSUnresolvedReference
                            Dashboard.showLoadingMsg();
                            // noinspection JSUnresolvedReference
                            ApiClient.ajax({
                                type: "POST",
                                url: ApiClient.getUrl('/' + this.pluginName + '/ResetProcessedItems?subscriptionId=' + id),
                            }).then((result) => {
                                // noinspection JSUnresolvedReference
                                Dashboard.hideLoadingMsg();
                                this.showToast("Verarbeitete Items für Abonnement zurückgesetzt.");
                                this.loadConfig(); // Refresh the configuration to update the UI
                            }).catch((err) => {
                                // noinspection JSUnresolvedReference
                                Dashboard.hideLoadingMsg();
                                this.showToast("Fehler beim Zurücksetzen der verarbeiteten Items: " + (err.responseJSON ? err.responseJSON.detail : "Unbekannter Fehler"));
                            });
                        }
                    });
                }

                addQueryRow(query) {
                    if (query == null) {
                        query = {query: '', fields: ['title', 'topic']};
                    }
                    const queryText = query ? query.query : '';
                    const fields = query ? query.fields : ['title', 'topic'];

                    const input = this.dom.create('input', {
                        type: 'text',
                        className: 'subQueryText',
                        value: queryText,
                        attributes: {
                            'is': 'emby-input',
                            'placeholder': 'Suchtext',
                            'required': 'true'
                        }
                    });

                    const cbTitle = this.dom.createCheckbox('Titel', fields.includes('title'), {
                        value: 'title',
                        className: 'subQueryField'
                    });
                    const cbTopic = this.dom.createCheckbox('Thema', fields.includes('topic'), {
                        value: 'topic',
                        className: 'subQueryField'
                    });
                    const cbChannel = this.dom.createCheckbox('Sender', fields.includes('channel'), {
                        value: 'channel',
                        className: 'subQueryField'
                    });

                    const removeBtn = this.dom.createIconButton('remove_circle_outline', 'Anfrage entfernen', (e) => {
                        e.target.closest('.mvpl-query-row').remove();
                    });
                    removeBtn.classList.add('btnRemoveQuery');

                    const newRow = this.dom.create('div', {
                        className: 'mvpl-query-row',
                        children: [
                            this.dom.create('div', {className: 'flex-grow', children: [input]}),
                            this.dom.create('div', {
                                className: 'query-checkboxes',
                                children: [cbTitle, cbTopic, cbChannel]
                            }),
                            removeBtn
                        ]
                    });

                    document.getElementById('queriesContainer').appendChild(newRow);
                }

                saveSubscription() {
                    const subData = this.subscriptionEditor.getEditorValues();

                    if (subData.Queries.length === 0) {
                        this.showToast("Bitte mindestens eine Suchanfrage definieren.");
                        return;
                    }

                    if (!this.currentConfig.Subscriptions) this.currentConfig.Subscriptions = [];

                    if (subData.Id) {
                        const idx = this.currentConfig.Subscriptions.findIndex(function (s) {
                            return s.Id === subData.Id;
                        });
                        if (idx > -1) {
                            // Keep existing ID logic if needed, but here subData already has ID from hidden input if set
                            var existingId = this.currentConfig.Subscriptions[idx].Id;

                            // Preserve IsEnabled state
                            var existingIsEnabled = this.currentConfig.Subscriptions[idx].IsEnabled;
                            if (existingIsEnabled === undefined) existingIsEnabled = true;

                            this.currentConfig.Subscriptions[idx] = subData;
                            this.currentConfig.Subscriptions[idx].Id = existingId; // Ensure ID consistency
                            this.currentConfig.Subscriptions[idx].IsEnabled = existingIsEnabled;
                        }
                    } else {
                        subData.Id = this.genUUID();
                        subData.IsEnabled = true; // Default enabled for new subs
                        this.currentConfig.Subscriptions.push(subData);
                    }

                    this.saveGlobalConfig();
                    this.subscriptionEditor.close();
                    this.renderSubscriptionsList();
                }

                deleteSubscription(id) {
                    this.confirmationPopup("Soll dieses Abonnement wirklich gelöscht werden?", "Löschen bestätigen", (confirmed) => {
                        if (confirmed) {
                            this.currentConfig.Subscriptions = this.currentConfig.Subscriptions.filter(function (s) {
                                return s.Id !== id;
                            });
                            this.saveGlobalConfig();
                            this.renderSubscriptionsList();
                        }
                    });
                }

                openAdvancedDownloadDialog(item) {
                    this.currentItemForAdvancedDl = item;
                    if (!this.currentItemForAdvancedDl) return;

                    document.getElementById('advancedDownloadTitle').innerText = 'Erweiterter Download: ' + this.currentItemForAdvancedDl.title;
                    document.getElementById('advancedDownloadIndex').value = ""; // Not needed anymore contextually but keeping element

                    document.getElementById('advDlPath').value = this.currentConfig.DefaultDownloadPath || '';

                    let proposedFilename = (this.currentItemForAdvancedDl.topic || 'video') + " - " + (this.currentItemForAdvancedDl.title || 'video');
                    proposedFilename = proposedFilename.replace(/["\/\\?%*:|<>]/g, '-') + '.mp4';
                    document.getElementById('advDlFilename').value = proposedFilename;


                    let advDlSub = document.getElementById('advDlSubtitles');
                    let advDlSubDesc = document.getElementById('advDlSubtitlesDesc');
                    if (!this.currentItemForAdvancedDl.url_subtitle) {
                        advDlSub.checked = false;
                        advDlSub.disabled = true;
                        advDlSubDesc.textContent = "Keine Untertitel verfügbar für dieses Video.";
                    }
                    else {
                        advDlSub.disabled = false;
                        advDlSubDesc.textContent = "";
                    }



                    document.getElementById('advancedDownloadModal').style.display = 'flex';
                }

                closeAdvancedDownloadDialog() {
                    document.getElementById('advancedDownloadModal').style.display = 'none';
                }

                performAdvancedDownload() {
                    if (!this.currentItemForAdvancedDl) return;

                    const downloadOptions = {
                        item: this.currentItemForAdvancedDl,
                        downloadPath: document.getElementById('advDlPath').value,
                        fileName: document.getElementById('advDlFilename').value,
                        downloadSubtitles: document.getElementById('advDlSubtitles').checked
                    };

                    const url = ApiClient.getUrl('/' + this.pluginName + '/AdvancedDownload');

                    Dashboard.showLoadingMsg();
                    ApiClient.ajax({
                        type: "POST",
                        url: url,
                        data: JSON.stringify(downloadOptions),
                        contentType: 'application/json'
                    }).then((result) => {
                        Dashboard.hideLoadingMsg();
                        this.closeAdvancedDownloadDialog();
                        this.showToast("Download für '" + this.currentItemForAdvancedDl.title + "' gestartet.");
                    }).catch((err) => {
                        Dashboard.hideLoadingMsg();
                        this.showToast("Fehler beim Starten des Downloads: " + (err.responseJSON ? err.responseJSON.detail : "Unbekannter Fehler"));
                    });
                }

                testSubscription() {
                    const subData = this.subscriptionEditor.getEditorValues();
                    if (subData.Queries.length === 0) {
                        this.showToast("Bitte mindestens eine Suchanfrage definieren.");
                        return;
                    }

                    // If ID is empty (new subscription), generate a temporary one for the backend to accept the object
                    if (!subData.Id) {
                        subData.Id = this.genUUID();
                    }

                    const url = ApiClient.getUrl('/' + this.pluginName + '/TestSubscription');

                    Dashboard.showLoadingMsg();
                    ApiClient.ajax({
                        type: "POST",
                        url: url,
                        data: JSON.stringify(subData),
                        contentType: 'application/json',
                        dataType: 'json'
                    }).then((results) => {
                        Dashboard.hideLoadingMsg();
                        if (typeof results === 'string') {
                            try {
                                results = JSON.parse(results);
                            } catch (e) {
                                console.error("Failed to parse JSON results", e);
                            }
                        }
                        this.renderTestResults(results);
                        document.getElementById('testSubscriptionModal').style.display = 'flex';
                    }).catch((err) => {
                        Dashboard.hideLoadingMsg();
                        console.error("Test subscription error:", err);
                        this.showToast("Fehler beim Testen des Abos: " + (err.responseJSON ? err.responseJSON.detail : (err.message || "Unbekannter Fehler")));
                    });
                }

                closeTestSubscriptionDialog() {
                    document.getElementById('testSubscriptionModal').style.display = 'none';
                }

                renderTestResults(results) {
                    const container = document.getElementById('testSubscriptionResults');
                    const countContainer = document.getElementById('testSubscriptionCount');
                    container.textContent = "";
                    countContainer.textContent = "";

                    if (!results || results.length === 0) {
                        const noRes = document.createElement('p');
                        noRes.textContent = "Keine Treffer für diese Konfiguration.";
                        container.appendChild(noRes);
                        return;
                    }

                    countContainer.textContent = results.length + " Einträge gefunden, die heruntergeladen würden:";

                    const paperList = document.createElement('div');
                    paperList.classList.add('paperList');

                    results.forEach((item) => {
                        const durationStr = Math.floor(item.duration / 60) + " Min";
                        const title = item.title;
                        const bodyText1 = item.channel + ' | ' + item.topic + ' | ' + durationStr;
                        const bodyText2 = item.description || '';

                        paperList.appendChild(this.createListItem(title, bodyText1, bodyText2, null));
                    });
                    container.appendChild(paperList);
                }

                /**
                 * Binds all event listeners for static HTML elements.
                 */
                bindEvents() {
                    // Page Show
                    document.querySelector('#MediathekViewDLConfigPage').addEventListener('pageshow', () => {
                        this.loadConfig();
                    });

                    // Tab Navigation
                    document.getElementById('mvpl-btn-tab-search').addEventListener('click', () => this.switchTab('search'));
                    document.getElementById('mvpl-btn-tab-settings').addEventListener('click', () => this.switchTab('settings'));
                    document.getElementById('mvpl-btn-tab-subscriptions').addEventListener('click', () => this.switchTab('subscriptions'));
                    document.getElementById('mvpl-btn-tab-downloads').addEventListener('click', () => this.switchTab('downloads'));

                    // Main Config Form
                    document.getElementById('MediathekGeneralConfigForm').addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.currentConfig.DefaultDownloadPath = document.querySelector('#txtDefaultDownloadPath').value;
                        this.currentConfig.DownloadSubtitles = document.querySelector('#chkDownloadSubtitles').checked;
                        this.currentConfig.AllowUnknownDomains = document.querySelector('#chkAllowUnknownDomains').checked;
                        this.currentConfig.ScanLibraryAfterDownload = document.querySelector('#chkScanLibraryAfterDownload').checked;
                        this.currentConfig.EnableStrmCleanup = document.querySelector('#chkEnableStrmCleanup').checked;
                        const minFreeSpaceMiB = parseInt(document.querySelector('#txtMinFreeDiskSpaceMiB').value, 10);
                        this.currentConfig.MinFreeDiskSpaceBytes = isNaN(minFreeSpaceMiB) ? (1.5 * 1024 * 1024 * 1024) : (minFreeSpaceMiB * 1024 * 1024);

                        const maxBandwidth = parseInt(document.querySelector('#txtMaxBandwidthMBits').value, 10);
                        this.currentConfig.MaxBandwidthMBits = isNaN(maxBandwidth) ? 0 : maxBandwidth;

                        this.saveGlobalConfig();
                        return false;
                    });

                    // Path selector in main config
                    document.getElementById('btnSelectPath').addEventListener('click', () => {
                        this.openFolderDialog('txtDefaultDownloadPath', 'Standard Download Pfad wählen');
                    });
                    // Path selectors in subscription editor
                    document.getElementById('btnSelectSubPath').addEventListener('click', () => {
                        this.openFolderDialog('subPath', 'Abo Pfad wählen');
                    });
                    // Path selector in advanced download dialog
                    document.getElementById('btnSelectAdvPath').addEventListener('click', () => {
                        this.openFolderDialog('advDlPath', 'Download Pfad wählen');
                    });

                    // Subscription Management
                    document.getElementById('mvpl-btn-new-sub').addEventListener('click', () => {
                        this.subscriptionEditor.show(null);
                    });

                    document.getElementById('mvpl-form-subscription').addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.saveSubscription();
                        return false;
                    });

                    document.getElementById('mvpl-btn-add-query').addEventListener('click', () => {
                        this.addQueryRow();
                    });

                    document.getElementById('mvpl-btn-test-sub').addEventListener('click', () => {
                        this.testSubscription();
                    });

                    document.getElementById('mvpl-btn-cancel-sub').addEventListener('click', () => {
                        this.subscriptionEditor.close();
                    });

                    // Test Results
                    document.getElementById('mvpl-btn-close-test-results').addEventListener('click', () => {
                        this.closeTestSubscriptionDialog();
                    });

                    // Advanced Download
                    document.getElementById('mvpl-adv-download-form').addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.performAdvancedDownload();
                        return false;
                    });

                    document.getElementById('mvpl-btn-close-adv-download').addEventListener('click', () => {
                        this.closeAdvancedDownloadDialog();
                    });
                }

                init() {
                    this.bindEvents();
                    this.searchController.init();
                    this.dependencyManager.init();
                }
            }

            const mediathekConfig = new MediathekPluginConfig();
            window.MediathekViewDL = {
                config: mediathekConfig,
                editor: mediathekConfig.subscriptionEditor
            };
            mediathekConfig.init();
        })();
    </script>
    <style>
        .mvpl-tabs-spacer {
            margin-bottom: 20px;
            border-bottom: 1px solid #333;
        }

        .mvpl-tabs-spacer button.selected {
            color: #00a4dc;
        }

        .mvpl-dialog-host {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .mvpl-dialog-content {
            background-color: #202020;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 5px;
            width: 70%;
            max-width: 800px;
            max-height: 60vh;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .button-row {
            display: flex;
            justify-content: flex-start;
            gap: 10px;
            margin-top: 20px;
        }

        /* Helper & Layout Classes */
        .flex-grow {
            flex-grow: 1;
        }

        .flex-align-center {
            display: flex;
            align-items: center;
        }

        .flex-space-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .flex-gap-5 {
            display: flex;
            gap: 5px;
        }

        .flex-gap-10 {
            display: flex;
            gap: 10px;
        }

        .mvpl-margin-top-10 {
            margin-top: 10px;
        }

        .mvpl-margin-top-20 {
            margin-top: 20px;
        }

        /* Specific Components */
        .mvpl-search-form-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .mvpl-input-short {
            width: 150px;
        }

        .mvpl-results-container {
            margin-top: 20px;
        }

        .mvpl-folder-button {
            margin-left: 10px;
            margin-top: 15px;
        }

        .mvpl-last-run-label {
            padding: 10px 0;
        }

        .mvpl-subscription-editor {
            display: none;
            border-top: 1px solid #444;
            margin-top: 20px;
            padding-top: 20px;
        }

        .mvpl-queries-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 10px;
        }

        .mvpl-query-row {
            display: flex;
            gap: 10px;
            align-items: center;
            border: 1px solid #333;
            padding: 10px;
            border-radius: 5px;
        }

        .query-checkboxes {
             display: flex;
             gap: 15px;
        }

        .mvpl-duration-inputs-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .mvpl-indented-block {
            margin-left: 20px;
        }

        .sub-disabled {
            opacity: 0.6;
        }

        .mvpl-modal-title {
            margin-top: 0;
        }

        .mvpl-test-sub-count {
            margin-bottom: 10px;
            font-weight: bold;
        }

        .mvpl-test-sub-results {
            overflow-y: auto;
            flex-grow: 1;
            margin-bottom: 20px;
        }

        .mvpl-download-status {
            background-color: #FFF;
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
        }

        .mvpl-download-status[data-status="Queued"] {
            background-color: #888;
            color: black;
        }

        .mvpl-download-status[data-status="Downloading"] {
            background-color: #00a4dc;
            color: black;
        }

        .mvpl-download-status[data-status="Processing"] {
            background-color: #00a4dc;
            color: black;
        }

        .mvpl-download-status[data-status="Finished"] {
            background-color: #4CAF50;
            color: white;
        }

        .mvpl-download-status[data-status="Failed"] {
            background-color: #F44336;
            color: white;
        }

        .mvpl-download-status[data-status="Cancelled"] {
            background-color: #FF9800;
            color: white;
        }

        /* Animation Classes */
        .mvpl-animated-container {
            transition: opacity 0.3s ease-in-out, max-height 0.3s ease-in-out, margin 0.3s ease-in-out, padding 0.3s ease-in-out;
            max-height: 200px; /* Sufficient for checkbox containers */
            opacity: 1;
            overflow: hidden;
            display: block; /* Ensure it is not none */
        }

        .mvpl-hidden {
            max-height: 0;
            opacity: 0;
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            pointer-events: none;
        }
    </style>
</div>
</body>
</html>
